---
title: 通过epoll理解协程
date: 2024-07-13 21:43:53
tags: [协程, Go, C]
---



# IO多路复用

## C10K问题

在互联网的最早期，网络上设备很少，那时每个连接都需要一个进程来处理。一些老的处理方式（如CGI）也沿用了多进程的思路来处理连接。但随着互联网规模快速扩大，一个服务器要同时服务的人越来越多，这也就产生了著名的C10K问题，也就是一个服务器如何处理一万个客户端同时连接。

## 进程与线程的局限性

进程出现后又出现了线程，相比进程，线程切换的创建与代价更低。也出现了进程池、线程池这样的技术，用于避免频繁创建和销毁的开销，仅保留切换的开销。但这些处理方案都有一个特点：一个进程或线程同时只能处理一个连接，即使连接空闲，线程也不能处理其他连接，这期间线程只能等待。

那么一个线程只能处理一个连接吗？显然不是的，线程和网络并没有什么必然的关联，一个线程既可以同时处理多个网络连接，一个网络连接也可以被多个线程处理。

## select, poll 与 epoll

为了让一个线程同时处理多个连接，系统开发者们设计了IO多路复用机制。在Linux上有三类系统调用：`select`, `poll` 与 `epoll`，在UNIX类系统中与`epoll`对应的则是`kqueue`。

### select 与 poll

在看IO多路复用的实现前，我们先看看线程是怎么处理一个连接的。线程使用`read / write`或`recv / send`系统调用来读/写一个连接，每个连接在操作系统内核中都有一个读写缓冲区。读时如果内核缓冲区中还没有数据，操作系统会让线程阻塞等待，直到缓冲区中有数据，此时读操作返回数据；写时如果内核缓冲区已满，则操作也会被阻塞，直到将全部的数据写入缓冲区。这期间网卡会不断工作，将收到数据送入内核的读缓冲区，并将内核写缓冲区的内容发送出去。最后线程关闭连接，操作结束。

了解了上面的原理，再去理解IO多路复用就变成了一个简单的思路转变：当一个连接无法读写时，不要让操作系统等待，而是让操作系统立刻返回并告知因为无数据/数据已满而无法读写，此时线程就可以暂时放弃它而去检查另一个连接是否可读写了。这就是IO多路复用的基石：非阻塞IO。

检查连接是否可读写需要进行一次系统调用，检查很多个连接则需要进行很多次系统调用，而系统调用相比普通函数调用速度稍慢，操作系统的开发者们为了加快这一操作，开发了一次性可以检查多个连接是否可读写的系统调用：`selelct`和`poll`。

这两个系统调用都只需要用到一个函数，其思路是相同的。使用者将所有需要检查读写的连接全部放入给定的结构中后，发起该调用。此时线程会等待，直到这其中有读写发生或达到设定的超时时间。类似于操作系统在内部帮你一次次检查你提供的连接中有没有连接可以读写。当返回后，用户程序通过遍历检查返回数组中的元素来确认哪个连接可以被读/写了。

但这种方式仍然有可优化的空间。

内核通常不会直接通过指针访问用户程序的内存，而是需要先从用户空间内复制到内核空间。而select和poll每次都将全部需要监控的连接提交到内核，这导致每次都需要内核和用户程序中复制较多的数据，并且用户程序还需要遍历检查。为了优化这些问题，Linux 2.5.44版本中提供了epoll系统调用。

### epoll

从上文`select`和`poll`提供的功能可以看出，它们在内核中是无状态的，这意味着每次对它们的调用都是独立的，每次调用都需要提供全部感兴趣的连接。但实践中显然感兴趣的连接并不会突然变化，通常连接从开始到结束，程序一直都对其感兴趣，所以可以从内核中维护状态，程序只需要在需要的时候添加和删除即可（通常是连接`accept`后添加，`close`前删除，不过`close`会自动删除）。

由于需要在内核中维护状态，`epoll`提供了三个系统调用`epoll_cerate`, `epoll_ctl`, `epoll_wait`。`epoll_create`用于创建epoll实例，让内核开始维护状态，`epoll_ctl`可以添加、删除或修改感兴趣的连接，`epoll_wait`则用于等待，当有一个或多个连接有感兴趣的事件时，`epoll_wait`会返回这些事件。由于只返回了实际发生了事件的连接，所以`epoll`可以尽量减少内核态到用户态的拷贝。

这是当前Linux下大多数异步程序使用的方式。

## io_uring 与 IOCP

io_uring是解决Linux在磁盘IO场景下的弱势的，在io_uring出现之前，Linux的异步磁盘IO通常是使用其他线程来完成，如`tokio`、`libuv`均使用线程池来处理文件的异步操作。只有部分数据库软件才会用那个又难用又复杂的Linux aio（可以说说就是这些数据库软件的开发者为了数据库高效读写磁盘才开发的）。

除了处理异步磁盘IO，io_uring也可以用于高效处理异步网络IO，由于数据拷贝有单独的内核线程来完成，而非`read / write`系统调用这种由用户线程发起的系统调用来完成，当前（2024年）在单线程场景下，io_uring要比epoll快一些，但多线程场景差距不大。io_uring的相比epoll减少了系统调用的次数，并且可以使用轮询方式彻底避免系统调用带来的开销。

IOCP是Windows上用于处理异步IO的接口，其原理与io_uring类似，但出现要更早。

# 什么是协程

## 事件驱动编程

有了`epoll`的帮助，用户态编程就可以更轻松的处理更多同时发生的连接了。

一个线程处理一个连接只需要按照逻辑进行`read`和`write`就可以了，执行状态会自然保存在线程的执行栈中。但有多个连接时，就需要分别记录下每个连接的执行状态，为此出现了事件驱动模型。简单地说，事件驱动的控制流不再是顺序的，而是被拆分成了一个个函数，每当一个新事件到来，就会触发这个事件类型对应的函数。下面用简单的C代码来表示。

```C
#define BUF_SIZE 4096
struct socket {
    int fd;
    char *read_buf;
    ssize_t read_size;
    
    char *write_buf;
    ssize_t write_size;
}

void on_read(struct socket *s) {
    // 收到读事件的时候一定能读出点什么东西，不考虑错误
    s->read_size = read(s->fd, s->read_buf, BUF_SIZE);
    process_http(s->read_buf, s->read_size);
    strncpy("HTTP/1.1 200 OK\r\n", s->write_buf, BUF_SIZE);
    on_write(s); // 立刻尝试写，写不下去在再考虑其他问题
}

void on_write(struct socket *s) {
    // 最简化，忽略写不完的情况
    // 读后立刻触发一次写，但可能因为缓冲区满写不进去，那就返回，等之后写event到来再写
    ssize_t w = write(s->fd, s->write_buf, s->write_size);
    if (w < 0 && (errno == EWOULDBLOCK || errno == EAGAIN)) {
    	return;
    }
    close(s->fd);
}

void on_hangup(struct socket *s) { /* ... */ }

void event_loop() {
    while (1) {
	    int num_events = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
        for (int i = 0; i < num_events; i++) {
            if (events[i].events & EPOLLUP) {
            	on_read(events[i].data.ptr);
            } else if (events[i].events & EPOLLOUT) {
                on_write(events[i].data.ptr);
            } /* ... */
        }
	}
}
```

在事件驱动编程模式下，控制流不再是从上到下，而是根据事件的类型选择对应的函数执行。这种由外部信号主导、不保证执行顺序的编程范式通常被称为异步编程。

这种编程模型通过将状态保存到额外结构中可以有效管理大量连接的状态，但显然也会使开发的控制流变得复杂，阻塞开发模式下，程序员只需要关注当前位置的代码即可。然而事件驱动编程导致程序的控制流会在多个函数间反复变化，这些函数间可能相距很远，并且需要区分函数内的状态和在额外的结构中保存的持久状态，无疑加重了程序员的编码负担。

## 简化编程步骤

为了让语句尽可能集中在一处而非分散在多处，开发者们在事件驱动编程的基础上又衍生了许多开发方式。

以JavaScript为例，首先是闭包回调，通过闭包将类转换为闭包函数，这种方式不仅将代码位置合并到一起，而且状态也可以直接由闭包捕获，减少了非常多的工作量，但这种方式仍然有较大的缺点。首先是回调地狱，多次非阻塞调用就需要多个回调，而每个回调都会嵌套，导致多个回调中缩进非常复杂，并且由于回调函数仅仅代表将来会执行，接下来函数还是会执行下面的代码，导致控制流仍然不清晰。

```javascript
setTimeout(function() { //第一层
    console.log('我是第一个执行');
    setTimeout(function() { //第二程
        console.log('我第二个执行');
        setTimeout(function() { //第三层
            console.log('我第三个执行');
        }, 1000);
        console.log('但我在第二个和第三个之间执行');
    }, 2000);
    console.log('而我在第一个和第二个之间执行')
}, 3000)
```

为此，JavaScript又推出了`Promise`，这稍微缓解了一些回调地狱引起的问题。但是依然存在异常控制流不清晰，多个闭包间难以共享变量等等情况。

```javascript
new Promise((resolve)=>{
        console.log('我第一个执行');
    	resolve(0);
    	console.log('我第二个执行')
    })
    .then(() => {
        return new Promise(resolve => setTimeout(resolve, 1000));
    })
    .then(r=>console.log('我第三个执行'))
```

在经过多年的尝试与改进后，几乎所有主流编程语言都选择了同一个方向：协程。

## 协程解决了什么问题

通过上面三个例子，我们可以看到事件驱动编程模型的缺点的主要原因：控制流由事件决定，而非逻辑决定，程序员必须照顾随时可能到来的事件，进而导致逻辑难以组织。而传统的同步编程，逻辑就清晰多了。

所以，协程的根本目标就在于：让程序员像编写同步代码一样编写异步代码。我们可以想象一个函数`yield`，当读写遇到阻塞时，可以将执行权交出去，而当收到可以读写的事件时，又可以回到交出执行权的那个地方。

```C
ssize_t unblocking_read(int fd, void *buf, ssize_t size) {
    while (1) {
        ssize_t ret = read(fd, buf, size);
        if (ret < 0 && (errno == EWOULDBLOCK || errno == EAGAIN)) {
            yield(); // 神奇的函数，能够跳出执行流程，去执行其他等待的函数，当有事件来的时候再从这里恢复
        } else {
            return ret;
        }
    }
}
ssize_t unblockint_write(int fd, void *buf, ssize_t size); // 与写类似

void process_http(int fd) {
    char buf[4096];
    ssize_t size = unblocking_read(fd, buf, sizeof(buf));
    proc_http_header(buf, size);
    unblocking_write(fd, "HTTP/1.1 200 OK\r\n");
    close(fd);
    return 0;
}
```

这就是协程的核心思想：通过包装让非阻塞调用的行为与阻塞调用类似，让程序员可以重新专注在逻辑维护而非状态维护上。可以看到相比上面的事件驱动模型，这里的核心函数`process_http`简化了非常多。

# 如何实现协程

主流的协程实现方式有两种，不需要额外函数调用栈的无栈协程与需要额外调用栈的有栈协程。

## 有栈协程

通常有栈协程被称为用户线程、虚拟线程、绿色线程、纤程等。从名字上就可以看出，有栈协程使用的思路与操作系统的线程一致，它为每个协程开辟独立的栈空间，但相较于操作系统的调度，有栈协程的调度需要保存的寄存器更少、无需进入内核态，并且调度时机也由程序自身控制，所以切换代价更低。其中Golang的goroutine、Java 21的虚拟线程都属于有栈协程。由于保留了函数的全部调用栈数据，这使得有栈协程的异步代码可以和同步代码没有任何区别，编写时不会增加任何额外的心智负担。这其中最具代表性的就是Golang，Golang从语言和标准库层面封装了常见阻塞操作的非阻塞版本，使用Golang编写代码几乎和使用多线程处理连接几乎完全一致，这使得迁移非常容易。

另外，有栈协程可以完全在运行时实现，而无需编译器的支持，例如C++的`libgo`库就是通过替换阻塞系统调用和运行时操作来达成和Golang类似的效果的。

我的这个[仓库](https://github.com/zytyan/epoll_coroutine_study/tree/main)使用C语言实现了一个简单的单线程有栈协程，可以处理网络连接、协程睡眠两种情况，这个程序通过`setjmp`和很少量汇编编写。所以这个库只能用于X86-64 Linux环境。如果有机会我可以单独开一篇文章写如何实现协程。

## 无栈协程

无栈协程与有栈协程相对，其不保留函数的调用栈，只保留必要的变量。由于这个限制，产生了无栈协程的最大特点：必须要使用类似`async / await`的关键字标识协程函数与协程的切换时机。需要注意的是，有栈协程也可以使用类似的关键字，只是并非必须使用。

相比有栈协程，无栈协程需要的内存和额外保留的数据更少，但进行协程切换的时机则被固定在了`await`时。无栈协程通常使用闭包的思路实现：分析每个可能跨`await`使用的变量，将它们存放在堆上；同时将每个`await`块拆分成独立的函数，进行`await`时相当于返回包含必要局部变量的闭包等待调度。例如JavaScript的协程就是对`Promise`的一种包装和优化。可以看到，想要使用无栈协程，就必须要编译器提供支持。

大部分使用`async / await`的语言均为无栈协程实现，例如Python、JavaScript、Rust、C#等。



## 

### 
